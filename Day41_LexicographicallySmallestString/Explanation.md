# Day 41 ‚Äì Lexicographically Smallest String After Applying Operations (LeetCode #1625)

## üß© Problem
You are given a string `s` of even length consisting of digits from `0-9`, and two integers `a` and `b`.

You can perform two operations any number of times:
1. **Add operation:** Add `a` to all digits at **odd indices** (mod 10).
2. **Rotate operation:** Rotate the string to the right by `b` positions.

Return the **lexicographically smallest string** obtainable after performing these operations in any sequence.

---

## üí° Approach / Idea
This problem can be solved using **Breadth-First Search (BFS)** over the state space of all possible strings generated by the two operations.

### Key Idea:
- Each string can produce **two new strings**:
  1. One by adding `a` to all digits at odd indices.
  2. Another by rotating it by `b` positions.
- Since operations can repeat, we use a **set** to avoid revisiting already-seen strings.
- We maintain the smallest string found during traversal.

### Steps:
1. Initialize a queue with the original string.
2. Use a `HashSet` to track visited strings.
3. For each string in the queue:
   - Apply both operations.
   - Enqueue unseen results.
   - Update the smallest lexicographic string found.
4. Once the queue is empty, return the smallest string.

---

## ‚è±Ô∏è Complexity
- **Time Complexity:** `O(n * 10 * n)` ‚Üí Each unique configuration explored once.  
- **Space Complexity:** `O(n * 10)` due to visited states.

---

## üßæ Example / Output
**Input:**  
`s = "5525", a = 9, b = 2`

**Output:**  
`"2050"`

**Explanation:**  
After a sequence of add and rotate operations, `"2050"` is the smallest string achievable.

---

## üß† Code (Java)
```java
class Solution {
    public String findLexSmallestString(String s, int a, int b) {
        Set<String> vis = new HashSet<>();
        String smallest = s;
        Deque<String> q = new ArrayDeque<>();
        q.offer(s);
        vis.add(s);

        while (!q.isEmpty()) {
            String cur = q.poll();
            if (cur.compareTo(smallest) < 0) smallest = cur;

            StringBuilder sb = new StringBuilder(cur);
            for (int i = 1; i < sb.length(); i += 2)
                sb.setCharAt(i, (char) ((sb.charAt(i) - '0' + a) % 10 + '0'));
            String added = sb.toString();
            if (vis.add(added)) q.offer(added);

            String rotated = cur.substring(cur.length() - b) + cur.substring(0, cur.length() - b);
            if (vis.add(rotated)) q.offer(rotated);
        }
        return smallest;
    }
}
ü™Ñ Summary / Insights

BFS ensures all possible operation sequences are explored.

Using a Set prevents infinite loops.

Efficiently finds the lexicographically smallest reachable string.